#include "shield.hh"
void shield::print_package ()
{
	cout << "/*\xa" "\x9" "Todo list for shield_package.sql:\xa" "\xa" "\x9" "Most of th"
"ese functions need more testing.\xa" "\xa" "\x9" "date_format has unimeplemen"
"ted commands.\xa" "\x9" "\xa" "*/\xa" "\xa" "SET SERVEROUTPUT ON;\xa" ""
"\xa" "/**\xa" "\x9" "This type is the implementation of the shield_arb_agg_cl"
"ob arbitrary aggregation function.\xa" "*/\xa" "create or replace type shield_"
"agg_arb_clob_t as object (\xa" "\xa" "\x9" "str_agg clob,\xa" "\xa" ""
"\x9" "static function ODCIAggregateInitialize (sctx in out shield_agg_arb_clob_"
"t) \xa" "\x9" "\x9" "return number,\xa" "\xa" "\x9" "member function ODCIA"
"ggregateIterate (self  in out shield_agg_arb_clob_t, \xa" "\x9" "             "
"                         value in     clob ) \xa" "\x9" "\x9" "return number,"
"\xa" "\xa" "\x9" "member function ODCIAggregateTerminate (self         in  sh"
"ield_agg_arb_clob_t, \xa" "\x9" "                                        retur"
"n_value out clob, \xa" "\x9" "                                        flags   "
"     in  number)               \xa" "\x9" "\x9" "            return number,"
"\xa" "\xa" "\x9" "member function ODCIAggregateMerge (self in out shield_agg_"
"arb_clob_t, \xa" "\x9" "                                    ctx2 in     shield"
"_agg_arb_clob_t) \xa" "\x9" "\x9" "return number\xa" ");\xa" "/\xa" ""
"\xa" "create or replace type body shield_agg_arb_clob_t is \xa" "\xa" ""
"\x9" "static function ODCIAggregateInitialize (sctx in out shield_agg_arb_clob_"
"t) \xa" "\x9" "\x9" "return number \xa" "\x9" "is \xa" "\x9" "begin"
"\xa" "\x9" "\x9" "sctx := shield_agg_arb_clob_t(null);\xa" "\x9" "\x9" "re"
"turn ODCIConst.Success;\xa" "\x9" "end;\xa" "\xa" "\x9" "member function OD"
"CIAggregateIterate (self  in out shield_agg_arb_clob_t,\xa" "\x9" "           "
"                           value in     clob) \xa" "\x9" "\x9" "return number"
" \xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "str_agg := value;"
"\xa" "\x9" "\x9" "return ODCIConst.Success;\xa" "\x9" "end;\xa" "\xa" ""
"\x9" "member function ODCIAggregateTerminate (self         in  shield_agg_arb_c"
"lob_t, \xa" "\x9" "                                        return_value out cl"
"ob, \xa" "\x9" "                                        flags        in  numbe"
"r) \xa" "\x9" "\x9" "return number \xa" "\x9" "is\xa" "\x9" "begin\xa" ""
"\x9" "\x9" "return_value := str_agg;\xa" "\x9" "\x9" "return ODCIConst.Succ"
"ess;\xa" "\x9" "end;\xa" "\xa" "\x9" "member function ODCIAggregateMerge (s"
"elf in out shield_agg_arb_clob_t, \xa" "\x9" "                                "
"    ctx2 in     shield_agg_arb_clob_t)\xa" "\x9" "\x9" "return number \xa" ""
"\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "return ODCIConst.Success;"
"\xa" "\x9" "end;\xa" "end;\xa" "/\xa" "\xa" "/**\xa" "\x9" "This type is"
" the implementation of the shield_arb_agg_char arbitrary aggregation function."
"\xa" "*/\xa" "create or replace type shield_agg_arb_char_t as object (\xa" ""
"\xa" "\x9" "char_agg varchar2 (4000),\xa" "\xa" "\x9" "static function ODCI"
"AggregateInitialize(sctx in out shield_agg_arb_char_t) \xa" "\x9" "\x9" "retu"
"rn number,\xa" "\xa" "\x9" "member function ODCIAggregateIterate (self  in ou"
"t shield_agg_arb_char_t, \xa" "\x9" "                                      val"
"ue in     varchar2) \xa" "\x9" "\x9" "return number,\xa" "\xa" "\x9" "memb"
"er function ODCIAggregateTerminate (self         in  shield_agg_arb_char_t, "
"\xa" "\x9" "                                        return_value out varchar2,"
" \xa" "\x9" "                                        flags        in  number) "
"              \xa" "\x9" "\x9" "return number,\xa" "\xa" "\x9" "member fun"
"ction ODCIAggregateMerge (self in out shield_agg_arb_char_t, \xa" "\x9" "     "
"                               ctx2 in     shield_agg_arb_char_t) \xa" "\x9" ""
"\x9" "return number\xa" ");\xa" "/\xa" "\xa" "create or replace type body s"
"hield_agg_arb_char_t is \xa" "\xa" "\x9" "static function ODCIAggregateInitia"
"lize (sctx in out shield_agg_arb_char_t) \xa" "\x9" "\x9" "return number "
"\xa" "\x9" "is \xa" "\x9" "begin\xa" "\x9" "\x9" "sctx := shield_agg_arb_"
"char_t(null);\xa" "\x9" "\x9" "return ODCIConst.Success;\xa" "\x9" "end;"
"\xa" "\xa" "\x9" "member function ODCIAggregateIterate (self  in out shield_a"
"gg_arb_char_t, \xa" "\x9" "                                      value in     "
"varchar2) \xa" "\x9" "\x9" "return number \xa" "\x9" "is\xa" "\x9" "begin"
"\xa" "\x9" "\x9" "char_agg := value;\xa" "\x9" "\x9" "return ODCIConst.Suc"
"cess;\xa" "\x9" "end;\xa" "\xa" "\x9" "member function ODCIAggregateTermina"
"te (self         in  shield_agg_arb_char_t, \xa" "\x9" "                      "
"                  return_value out varchar2, \xa" "\x9" "                     "
"                   flags        in  number) \xa" "\x9" "\x9" "return number "
"\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "return_value := char_agg"
";\xa" "\x9" "\x9" "return ODCIConst.Success;\xa" "\x9" "end;\xa" "\xa" ""
"\x9" "member function ODCIAggregateMerge (self in out shield_agg_arb_char_t, "
"\xa" "\x9" "                                    ctx2 in     shield_agg_arb_cha"
"r_t) \xa" "\x9" "\x9" "return number \xa" "\x9" "is\xa" "\x9" "begin"
"\xa" "\x9" "\x9" "return ODCIConst.Success;\xa" "\x9" "end;\xa" "end;"
"\xa" "/\xa" "\xa" "\xa" "/**\xa" "\x9" "This type is the implementation of"
" the shield_arb_agg_num arbitrary aggregation function.\xa" "*/\xa" "create or"
" replace type shield_agg_arb_num_t as object (\xa" "\xa" "\x9" "char_agg numb"
"er,\xa" "\xa" "\x9" "static function ODCIAggregateInitialize(sctx in out shie"
"ld_agg_arb_num_t) \xa" "\x9" "\x9" "return number,\xa" "\xa" "\x9" "member"
" function ODCIAggregateIterate (self  in out shield_agg_arb_num_t, \xa" ""
"\x9" "                                      value in     number) \xa" "\x9" ""
"\x9" "return number,\xa" "\xa" "\x9" "member function ODCIAggregateTerminate"
" (self         in  shield_agg_arb_num_t, \xa" "\x9" "                         "
"               return_value out number, \xa" "\x9" "                          "
"              flags        in  number)               \xa" "\x9" "\x9" "return"
" number,\xa" "\xa" "\x9" "member function ODCIAggregateMerge (self in out shi"
"eld_agg_arb_num_t, \xa" "\x9" "                                    ctx2 in    "
" shield_agg_arb_num_t) \xa" "\x9" "\x9" "return number\xa" ");\xa" "/"
"\xa" "\xa" "create or replace type body shield_agg_arb_num_t is \xa" "\xa" ""
"\x9" "static function ODCIAggregateInitialize (sctx in out shield_agg_arb_num_t"
") \xa" "\x9" "\x9" "return number \xa" "\x9" "is \xa" "\x9" "begin\xa" ""
"\x9" "\x9" "sctx := shield_agg_arb_num_t(null);\xa" "\x9" "\x9" "return ODC"
"IConst.Success;\xa" "\x9" "end;\xa" "\xa" "\x9" "member function ODCIAggreg"
"ateIterate (self  in out shield_agg_arb_num_t, \xa" "\x9" "                   "
"                   value in     number) \xa" "\x9" "\x9" "return number "
"\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "char_agg := value;"
"\xa" "\x9" "\x9" "return ODCIConst.Success;\xa" "\x9" "end;\xa" "\xa" ""
"\x9" "member function ODCIAggregateTerminate (self         in  shield_agg_arb_n"
"um_t, \xa" "\x9" "                                        return_value out num"
"ber, \xa" "\x9" "                                        flags        in  numb"
"er) \xa" "\x9" "\x9" "return number \xa" "\x9" "is\xa" "\x9" "begin"
"\xa" "\x9" "\x9" "return_value := char_agg;\xa" "\x9" "\x9" "return ODCICo"
"nst.Success;\xa" "\x9" "end;\xa" "\xa" "\x9" "member function ODCIAggregate"
"Merge (self in out shield_agg_arb_num_t, \xa" "\x9" "                         "
"           ctx2 in     shield_agg_arb_num_t) \xa" "\x9" "\x9" "return number "
"\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "return ODCIConst.Success"
";\xa" "\x9" "end;\xa" "end;\xa" "/\xa" "\xa" "/**\xa" "\x9" "Aggregate f"
"unction for picking an arbitrary element from a group. This is the clob version."
"\xa" "*/\xa" "\xa" "create or replace function shield_arb_agg_clob (input clo"
"b) \xa" "\x9" "return clob\xa" "\x9" "parallel_enable aggregate\xa" ""
"\x9" "using shield_agg_arb_clob_t;\xa" "/\xa" "\xa" "/**\xa" "\x9" "Aggreg"
"ate function for picking an arbitrary element from a group. This is the char ver"
"sion.\xa" "*/\xa" "\xa" "create or replace function shield_arb_agg_char (inpu"
"t varchar2) \xa" "\x9" "return varchar2\xa" "\x9" "parallel_enable aggregate"
" \xa" "\x9" "using shield_agg_arb_char_t;\xa" "/\xa" "\xa" "/**\xa" ""
"\x9" "Aggregate function for picking an arbitrary element from a group. This is"
" the numeric version.\xa" "*/\xa" "\xa" "create or replace function shield_ar"
"b_agg_num (input number) \xa" "\x9" "return number\xa" "\x9" "parallel_enabl"
"e aggregate \xa" "\x9" "using shield_agg_arb_num_t;\xa" "/\xa" "\xa" "/**"
"\xa" "\x9" "This type is used to pass around lists of table names in shield fo"
"r functions that construct weird queries based on introspection data.\xa" "*/"
"\xa" "create or replace type shield_list as varray (10) of varchar2(30);\xa" ""
"/\xa" "\xa" "create or replace package shield\xa" "is\xa" "\x9" "last_inser"
"t_id integer;\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "This function returns "
"the last auto_increment id.\xa" "\x9" "*/\xa" "\xa" "\x9" "function get_las"
"t_insert_id \xa" "\x9" "\x9" "return number;\xa" "\xa" "\x9" "/**\xa" ""
"\x9" "\x9" "This function takes a string containing a mysql-style date and con"
"verts it to an oracle date.\xa" "\x9" "*/\xa" "\x9" "function date_parse (st"
"r_date varchar2) \xa" "\x9" "\x9" "return date deterministic;\xa" "\xa" ""
"\x9" "/**\xa" "\x9" "\x9" "This function takes a string containing a mysql-s"
"tyle date and converts it to a number.\xa" "\x9" "*/\xa" "\x9" "function dat"
"e_numeric(str_date varchar2) \xa" "\x9" "\x9" "return number deterministic;"
"\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "This function takes a date and conv"
"erts it to a string in the same format mysql uses.\xa" "\x9" "*/\xa" "\x9" ""
"function date_char (da date) \xa" "\x9" "\x9" "return varchar2 deterministic;"
"\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "This is a workalike to the mysql cu"
"rdate function.\xa" "\x9" "*/\xa" "\x9" "function curdate \xa" "\x9" ""
"\x9" "return varchar2;\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "This is a wo"
"rkalike to the mysql date function.\xa" "\x9" "*/\xa" "\x9" "function date_ "
"(str_date varchar2) \xa" "\x9" "\x9" "return varchar2 deterministic;\xa" ""
"\xa" "\x9" "/**\xa" "\x9" "\x9" "This is a workalike to the mysql now funct"
"ion.\xa" "\x9" "*/\xa" "\x9" "function now \xa" "\x9" "\x9" "return varch"
"ar2;\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "This is a workalike to the mysq"
"l date_format function.\xa" "\x9" "*/\xa" "\x9" "function date_format (str_d"
"ate varchar2, format varchar2) \xa" "\x9" "\x9" "return varchar2 deterministi"
"c;\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "This function is a no-op. \xa" ""
"\xa" "\x9" "\x9" "The set of 'natural' functions are used to make sure that w"
"hen comparing different field values, clobs are implicitly converted to chars, s"
"o that no error is thrown.\xa" "\x9" "*/\xa" "\x9" "function natural (in_val"
" number) \xa" "\x9" "\x9" "return number deterministic;\xa" "\x9" "/**"
"\xa" "\x9" "\x9" "This function converts a clob to a char. \xa" "\xa" ""
"\x9" "\x9" "The set of 'natural' functions are used to make sure that when com"
"paring different field values, clobs are implicitly converted to chars, so that "
"no error is thrown.\xa" "\x9" "*/\xa" "\x9" "function natural (in_val clob) "
"\xa" "\x9" "\x9" "return varchar2 deterministic;\xa" "\x9" "/**\xa" ""
"\x9" "\x9" "This function is a no-op. \xa" "\xa" "\x9" "\x9" "The set of '"
"natural' functions are used to make sure that when comparing different field val"
"ues, clobs are implicitly converted to chars, so that no error is thrown.\xa" ""
"\x9" "*/\xa" "\x9" "function natural (in_val varchar2) \xa" "\x9" "\x9" "r"
"eturn varchar2 deterministic;\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "Perfor"
"m null-safe equal comaprison, i.e. mysql <=> operator\xa" "\x9" "*/\xa" ""
"\x9" "function null_safe_equal (v1 varchar2, v2 varchar) \xa" "\x9" "\x9" "r"
"eturn char deterministic;\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "Perform nu"
"ll-safe equal comaprison, i.e. mysql <=> operator\xa" "\x9" "*/\xa" "\x9" "f"
"unction null_safe_equal (v1 number, v2 number) \xa" "\x9" "\x9" "return char "
"deterministic;\xa" "\xa" "\x9" "/**\xa" "\x9" "\x9" "Perform null-safe equ"
"al comaprison, i.e. mysql <=> operator\xa" "\x9" "*/\xa" "\x9" "function nul"
"l_safe_equal (v1 clob, v2 clob) \xa" "\x9" "\x9" "return char deterministic;"
"\xa" "\xa" "\x9" "function equal (v1 number, v2 number) \xa" "\x9" "\x9" ""
"return char deterministic;\xa" "\xa" "\x9" "function equal (v1 clob, v2 clob)"
" \xa" "\x9" "\x9" "return char deterministic;\xa" "\xa" "\x9" "function eq"
"ual (v1 varchar2, v2 varchar2) \xa" "\x9" "\x9" "return char deterministic;"
"\xa" "\xa" "\x9" "function equal (v1 varchar2, v2 number) \xa" "\x9" ""
"\x9" "return char deterministic;\xa" "\xa" "\x9" "function equal (v1 number,"
" v2 varchar2) \xa" "\x9" "\x9" "return char deterministic;\xa" "\xa" ""
"\x9" "/**\xa" "\x9" "\x9" "This function creates and performs a select query"
" using _all_ columns from the tables in the \x5c" "c table_name varray, but with"
"out using a wildcard. This might seem useless (and it is) but it is needed since"
" you can not use wildcards in subselect queries, and shield uses subselect to em"
"ulate the mysql limit clause.\xa" "\x9" "*/\xa" "\x9" "function make_select_"
"limit_query (pre varchar2, post varchar2, table_name shield_list)\xa" "\x9" ""
"\x9" "return number;\xa" "\xa" "\x9" "function make_select_group_query (pre "
"varchar2, post varchar2, table_name shield_list, agg_name shield_list)\xa" ""
"\x9" "\x9" "return number;\xa" "\xa" "end shield;\xa" "/\xa" "\xa" "creat"
"e or replace package body shield\xa" "is\xa" "\xa" "        function get_last"
"_insert_id\xa" "\x9" "\x9" "return number\xa" "        is\xa" "\x9" "begin"
"\xa" "\x9" "\x9" "return last_insert_id;\xa" "\x9" "end;\xa" "\x9" ""
"\xa" "\x9" "/*\xa" "\x9" "\x9" "Convert a date or datetime to an oracle dat"
"e\xa" "\x9" "*/\xa" "\x9" "function date_parse (str_date varchar2) \xa" ""
"\x9" "\x9" "return date deterministic\xa" "\x9" "is \xa" "\x9" "begin"
"\xa" "\x9" "\x9" "if length (str_date) = 10 then\xa" "\x9" "\x9" "\x9" "r"
"eturn to_date (str_date, 'yyyy-mm-dd');\xa" "\x9" "\x9" "else\xa" "\x9" ""
"\x9" "\x9" "return to_date (str_date, 'yyyy-mm-dd hh24:mi:ss');\xa" "\x9" ""
"\x9" "end if;\xa" "\x9" "end;\xa" "\xa" "\x9" "/*\xa" "\x9" "\x9" "Conv"
"ert a date or datetime variable to its numeric representation\xa" "\x9" "*/"
"\xa" "\x9" "function date_numeric (str_date varchar2) \xa" "\x9" "\x9" "ret"
"urn number deterministic\xa" "\x9" "is \xa" "\x9" "\x9" "da date;\xa" ""
"\x9" "\x9" "str_res varchar2 (32);\xa" "\x9" "begin\xa" "\x9" "\x9" "da :"
"= date_parse (str_date);\xa" "\xa" "\x9" "\x9" "if length (str_date) = 10 th"
"en\xa" "\x9" "\x9" "\x9" "str_res := to_char (da, 'yyyymmdd');\xa" "\x9" ""
"\x9" "else\xa" "\x9" "\x9" "\x9" "str_res := to_char (da, 'yyyymmddhh24miss"
"');\xa" "\x9" "\x9" "end if;\xa" "\xa" "\x9" "\x9" "return to_number(str_"
"res);\x9" "\x9" "\xa" "\x9" "end;\xa" "\xa" "\x9" "/*\xa" "\x9" ""
"\x9" "Convert an oracle date object to a datetime\xa" "\x9" "*/\xa" "\x9" ""
"function date_char (da date) \xa" "\x9" "\x9" "return varchar2 deterministic"
"\xa" "\x9" "is\xa" "\x9" "\xa" "\x9" "begin\xa" "\x9" "\x9" "return to_"
"char (da, 'yyyy-mm-dd hh24:mi:ss');\xa" "\x9" "end;\xa" "\xa" "\x9" "/*"
"\xa" "\x9" "\x9" "Return the current date\xa" "\x9" "*/\xa" "\x9" "functi"
"on curdate \xa" "\x9" "\x9" "return varchar2\xa" "\x9" "is \xa" "\x9" "be"
"gin\xa" "\x9" "\x9" "return to_char (current_date, 'yyyy-mm-dd');\xa" ""
"\x9" "end;\xa" "\xa" "\x9" "/*\xa" "\x9" "\x9" "Return the date portion o"
"f a datetime variable\xa" "\x9" "*/\xa" "\x9" "function date_ (str_date varc"
"har2) \xa" "\x9" "\x9" "return varchar2 deterministic\xa" "\x9" "is \xa" ""
"\x9" "begin\xa" "\x9" "\x9" "return substr (str_date, 1, 10);\xa" "\x9" "e"
"nd;\xa" "\xa" "\x9" "function now return varchar2\xa" "\x9" "is \xa" ""
"\x9" "\x9" "tm varchar (32);\xa" "\x9" "begin\xa" "\x9" "\x9" "return dat"
"e_char (current_date);\xa" "\x9" "end;\xa" "\xa" "\x9" "function date_forma"
"t (str_date varchar2, \xa" "\x9" "                      format varchar2)"
"\xa" "\x9" "\x9" "return varchar2 deterministic\xa" "\x9" "is \xa" ""
"\x9" "\x9" "pos integer;\xa" "\x9" "\x9" "res varchar2 (256);\xa" "\x9" ""
"\x9" "chr varchar2 (1);\xa" "\x9" "\x9" "da date;\xa" "\x9" "begin\xa" ""
"\x9" "\x9" "pos  := 1;\xa" "\x9" "\x9" "res  := '';\xa" "\x9" "\x9" "da "
":= date_parse (str_date);\xa" "\xa" "\x9" "\x9" "while pos <= length (format"
") loop\xa" "\x9" "\x9" "\x9" "chr := substr (format,pos,1);\xa" "\x9" ""
"\x9" "\x9" "if chr = '%' then\xa" "\x9" "\x9" "\x9" "\x9" "pos := pos + 1"
";\x9" "\x9" "\x9" "\x9" "\xa" "\x9" "\x9" "\x9" "\x9" "chr := substr (f"
"ormat,pos,1);\xa" "\xa" "\x9" "\x9" "\x9" "\x9" "if chr = 'a' then\xa" ""
"\x9" "\x9" "\x9" "\x9" "\x9" "res := res || substr (to_char(da, 'Day'), 1, "
"3);\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'b' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || substr (to_char(da, 'month'), 1, 3);\xa" ""
"\x9" "\x9" "\x9" "\x9" "elsif chr = 'c' then\xa" "\x9" "\x9" "\x9" ""
"\x9" "\x9" "res := res || to_char(da, 'fmmm');\xa" "\x9" "\x9" "\x9" ""
"\x9" "elsif chr = 'D' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res "
"|| to_char(da, 'ddth');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'd' then"
"\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, 'dd');"
"\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'e' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || to_char(da, 'fmdd');\xa" "\x9" "\x9" ""
"\x9" "\x9" "elsif chr = 'f' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res "
":= res || '000000';\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'H' then"
"\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, 'hh24');"
"\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'h' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || to_char(da, 'hh12');\xa" "\x9" "\x9" ""
"\x9" "\x9" "elsif chr = 'I' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res "
":= res || to_char(da, 'hh12');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'i'"
" then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, 'mi');"
"\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'j' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || to_char(da, '');\xa" "\x9" "\x9" "\x9" ""
"\x9" "elsif chr = 'k' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res "
"|| to_char(da, 'hh24');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'l' then"
"\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, 'hh12');"
"\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'M' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || to_char(da, 'Month');\xa" "\x9" "\x9" ""
"\x9" "\x9" "elsif chr = 'm' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res "
":= res || to_char(da, 'mm');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'p' t"
"hen\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, '');"
"\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'r' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || to_char(da, '');\xa" "\x9" "\x9" "\x9" ""
"\x9" "elsif chr = 'S' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res "
"|| to_char(da, 'ss');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 's' then"
"\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, 'ss');"
"\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'T' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || to_char(da, 'hh24:mi:ss');\xa" "\x9" ""
"\x9" "\x9" "\x9" "elsif chr = 'U' then\xa" "\x9" "\x9" "\x9" "\x9" ""
"\x9" "res := res || to_char(da, '');\xa" "\x9" "\x9" "\x9" "\x9" "elsif ch"
"r = 'u' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, "
"'');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'V' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || to_char(da, '');\xa" "\x9" "\x9" "\x9" ""
"\x9" "elsif chr = 'v' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res "
"|| to_char(da, '');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'W' then"
"\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, 'fmDay');"
"\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'w' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "res := res || to_char(da, '');\xa" "\x9" "\x9" "\x9" ""
"\x9" "elsif chr = 'X' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res "
"|| to_char(da, '');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = 'x' then"
"\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || to_char(da, '');\xa" ""
"\x9" "\x9" "\x9" "\x9" "elsif chr = 'Y' then\xa" "\x9" "\x9" "\x9" ""
"\x9" "\x9" "res := res || to_char(da, 'yyyy');\xa" "\x9" "\x9" "\x9" ""
"\x9" "elsif chr = 'y' then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res "
"|| to_char(da, 'yy');\xa" "\x9" "\x9" "\x9" "\x9" "elsif chr = '%' then"
"\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || '%';\xa" "\x9" ""
"\x9" "\x9" "\x9" "else\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res ||"
" chr;\xa" "\x9" "\x9" "\x9" "\x9" "end if;\xa" "\xa" "\x9" "\x9" ""
"\x9" "else\xa" "\x9" "\x9" "\x9" "\x9" "res := res || chr;\xa" "\x9" ""
"\x9" "\x9" "end if;\xa" "\xa" "\x9" "\x9" "\x9" "pos := pos + 1;\xa" ""
"\x9" "\x9" "end loop;\xa" "\x9" "\x9" "return res;\xa" "\xa" "\x9" "end;"
"\xa" "\xa" "\x9" "function natural (in_val number) \xa" "\x9" "\x9" "retur"
"n number deterministic\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "re"
"turn in_val;\xa" "\x9" "end;\xa" "\xa" "\x9" "function natural (in_val clob"
") \xa" "\x9" "\x9" "return varchar2 deterministic\xa" "\x9" "is\xa" ""
"\x9" "begin\xa" "\x9" "\x9" "return to_char(in_val);\xa" "\x9" "end;"
"\xa" "\xa" "\x9" "function natural (in_val varchar2) \xa" "\x9" "\x9" "ret"
"urn varchar2 deterministic\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" ""
"\x9" "return in_val;\xa" "\x9" "end;\xa" "\xa" "\x9" "function null_safe_e"
"qual (v1 varchar2, v2 varchar) \xa" "\x9" "\x9" "return char deterministic"
"\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "if v1 is null then "
"\xa" "\x9" "\x9" "\x9" "if v2 is null then\xa" "\x9" "\x9" "\x9" ""
"\x9" "return 'Y';\xa" "\x9" "\x9" "\x9" "end if;\xa" "\x9" "\x9" ""
"\x9" "return 'N';\xa" "\x9" "\x9" "else\xa" "\x9" "\x9" "\x9" "if v2 is "
"null then\xa" "\x9" "\x9" "\x9" "\x9" "return 'N';\xa" "\x9" "\x9" ""
"\x9" "end if;\xa" "\x9" "\x9" "end if;\xa" "\xa" "\x9" "\x9" "if v1 = v2"
" then\xa" "\x9" "\x9" "\x9" "return 'Y';\xa" "\x9" "\x9" "end if;\xa" ""
"\x9" "\x9" "return 'N';\xa" "\x9" "end;\xa" "\xa" "\x9" "function null_sa"
"fe_equal (v1 clob, v2 clob) \xa" "\x9" "\x9" "return char deterministic"
"\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "if v1 is null then "
"\xa" "\x9" "\x9" "\x9" "if v2 is null then\xa" "\x9" "\x9" "\x9" ""
"\x9" "return 'Y';\xa" "\x9" "\x9" "\x9" "end if;\xa" "\x9" "\x9" ""
"\x9" "return 'N';\xa" "\x9" "\x9" "else\xa" "\x9" "\x9" "\x9" "if v2 is "
"null then\xa" "\x9" "\x9" "\x9" "\x9" "return 'N';\xa" "\x9" "\x9" ""
"\x9" "end if;\xa" "\x9" "\x9" "end if;\xa" "\xa" "\x9" "\x9" "if v1 = v2"
" then\xa" "\x9" "\x9" "\x9" "return 'Y';\xa" "\x9" "\x9" "end if;\xa" ""
"\x9" "\x9" "return 'N';\xa" "\x9" "end;\xa" "\xa" "\x9" "function null_sa"
"fe_equal (v1 number, v2 number) \xa" "\x9" "\x9" "return char deterministic"
"\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "if v1 is null then "
"\xa" "\x9" "\x9" "\x9" "if v2 is null then\xa" "\x9" "\x9" "\x9" ""
"\x9" "return 'Y';\xa" "\x9" "\x9" "\x9" "end if;\xa" "\x9" "\x9" ""
"\x9" "return 'N';\xa" "\x9" "\x9" "else\xa" "\x9" "\x9" "\x9" "if v2 is "
"null then\xa" "\x9" "\x9" "\x9" "\x9" "return 'N';\xa" "\x9" "\x9" ""
"\x9" "end if;\xa" "\x9" "\x9" "end if;\xa" "\xa" "\x9" "\x9" "if v1 = v2"
" then\xa" "\x9" "\x9" "\x9" "return 'Y';\xa" "\x9" "\x9" "end if;\xa" ""
"\x9" "\x9" "return 'N';\xa" "\x9" "end;\xa" "\xa" "\xa" "\x9" "function "
"equal (v1 number, v2 number) \xa" "\x9" "\x9" "return char deterministic"
"\xa" "\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "if v1 = v2 then\xa" ""
"\x9" "\x9" "\x9" "return 'Y';\xa" "\x9" "\x9" "end if;\xa" "\x9" ""
"\x9" "return 'N';\xa" "\x9" "end;\xa" "\xa" "\xa" "\x9" "function equal ("
"v1 varchar2, v2 varchar2) \xa" "\x9" "\x9" "return char deterministic\xa" ""
"\x9" "is\xa" "\x9" "begin\xa" "\x9" "\x9" "if v1 = v2 then\xa" "\x9" ""
"\x9" "\x9" "return 'Y';\xa" "\x9" "\x9" "end if;\xa" "\x9" "\x9" "return"
" 'N';\xa" "\x9" "end;\xa" "\xa" "\x9" "function equal (v1 clob, v2 clob) "
"\xa" "\x9" "\x9" "return char deterministic\xa" "\x9" "is\xa" "\x9" "begi"
"n\xa" "\x9" "\x9" "if v1 = v2 then\xa" "\x9" "\x9" "\x9" "return 'Y';"
"\xa" "\x9" "\x9" "end if;\xa" "\x9" "\x9" "return 'N';\xa" "\x9" "end;"
"\xa" "\xa" "\x9" "function equal (v1 number, v2 varchar2) \xa" "\x9" ""
"\x9" "return char deterministic\xa" "\x9" "is\xa" "\x9" "begin\xa" ""
"\x9" "\x9" "if to_char (v1) = v2 then\xa" "\x9" "\x9" "\x9" "return 'Y';"
"\xa" "\x9" "\x9" "end if;\xa" "\x9" "\x9" "return 'N';\xa" "\x9" "end;"
"\xa" "\xa" "\x9" "function equal (v1 varchar2, v2 number) \xa" "\x9" ""
"\x9" "return char deterministic\xa" "\x9" "is\xa" "\x9" "begin\xa" ""
"\x9" "\x9" "if v1 = to_char (v2) then\xa" "\x9" "\x9" "\x9" "return 'Y';"
"\xa" "\x9" "\x9" "end if;\xa" "\x9" "\x9" "return 'N';\xa" "\x9" "end;"
"\xa" "\xa" "\xa" "\x9" "function make_select_limit_query (pre varchar2, post"
" varchar2, table_name shield_list)\xa" "\x9" "\x9" "return number\xa" ""
"\x9" "is\xa" "\x9" "\x9" "/*\xa" "\x9" "\x9" "\x9" "Declare vars for cur"
"sor traversing over all columns of affected tables\xa" "\x9" "\x9" "*/\xa" ""
"\x9" "\x9" "type column_cursor_type is ref cursor return user_tab_columns%rowt"
"ype;\xa" "\x9" "\x9" "column_cursor column_cursor_type;\xa" "\x9" "\x9" "c"
"urrent_row user_tab_columns%rowtype;\xa" "\xa" "\x9" "\x9" "/*\xa" "\x9" ""
"\x9" "\x9" "Iterator variables\xa" "\x9" "\x9" "*/\xa" "\x9" "\x9" "t_na"
"me varchar (30);\xa" "\x9" "\x9" "i integer;\xa" "\xa" "\x9" "\x9" "/*"
"\xa" "\x9" "\x9" "\x9" "resulting query goes here\xa" "\x9" "\x9" "*/"
"\xa" "\x9" "\x9" "res varchar2 (4000);\xa" "\x9" "\x9" "\xa" "\x9" ""
"\x9" "/*\xa" "\x9" "\x9" "\x9" "flag for detecting first lap in loop\xa" ""
"\x9" "\x9" "*/\xa" "\x9" "\x9" "is_first boolean;\xa" "\x9" "begin\xa" ""
"\x9" "\x9" "res := pre;\xa" "\xa" "\x9" "\x9" "i := table_name.first;"
"\xa" "\x9" "\x9" "is_first := true;\xa" "\x9" "\x9" "while i is not null l"
"oop\xa" "\x9" "\x9" "\x9" "t_name := upper (table_name (i));\xa" "\x9" ""
"\x9" "\x9" "open column_cursor for select * from user_tab_columns where table_"
"name = t_name;\xa" "\x9" "\x9" "\x9" "loop\xa" "\x9" "\x9" "\x9" ""
"\x9" "fetch column_cursor into current_row;\xa" "\x9" "\x9" "\x9" "\x9" "e"
"xit when column_cursor%notfound;\xa" "\x9" "\x9" "\x9" "\x9" "if is_first ="
" true then\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "is_first := false;\xa" ""
"\x9" "\x9" "\x9" "\x9" "else\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res :="
" res || ',';\xa" "\x9" "\x9" "\x9" "\x9" "end if;\xa" "\x9" "\x9" ""
"\x9" "\x9" "res := res || ' ' || lower (t_name) || '.' || lower (current_row.c"
"olumn_name);\xa" "\x9" "\x9" "\x9" "end loop;\xa" "\xa" "\x9" "\x9" ""
"\x9" "i := table_name.next (i);\xa" "\x9" "\x9" "end loop;\xa" "\xa" ""
"\x9" "\x9" "res := res || ' ' || post;\x9" "\xa" "\x9" "\x9" "dbms_output."
"put_line( res);\xa" "\x9" "\x9" "return 0;\xa" "\x9" "end;\xa" "\xa" ""
"\x9" "function make_select_group_query (pre varchar2, post varchar2, table_name"
" shield_list, agg_name shield_list)\xa" "\x9" "\x9" "return number\xa" ""
"\x9" "is\xa" "\x9" "\x9" "/*\xa" "\x9" "\x9" "\x9" "Declare vars for cur"
"sor traversing over all columns of affected tables\xa" "\x9" "\x9" "*/\xa" ""
"\x9" "\x9" "type column_cursor_type is ref cursor return user_tab_columns%rowt"
"ype;\xa" "\x9" "\x9" "column_cursor column_cursor_type;\xa" "\x9" "\x9" "c"
"urrent_row user_tab_columns%rowtype;\xa" "\xa" "\x9" "\x9" "/*\xa" "\x9" ""
"\x9" "\x9" "Iterator variables\xa" "\x9" "\x9" "*/\xa" "\x9" "\x9" "t_na"
"me varchar (30);\xa" "\x9" "\x9" "i integer;\xa" "\xa" "\x9" "\x9" "/*"
"\xa" "\x9" "\x9" "\x9" "resulting query goes here\xa" "\x9" "\x9" "*/"
"\xa" "\x9" "\x9" "res varchar2 (4000);\xa" "\x9" "\x9" "\xa" "\x9" ""
"\x9" "/*\xa" "\x9" "\x9" "\x9" "flag for detecting first lap in loop\xa" ""
"\x9" "\x9" "*/\xa" "\x9" "\x9" "is_first boolean;\xa" "\xa" "\x9" ""
"\x9" "agg_func varchar2 (128);\xa" "\x9" "begin\xa" "\x9" "\x9" "res := pr"
"e;\xa" "\xa" "\x9" "\x9" "i := table_name.first;\xa" "\x9" "\x9" "is_firs"
"t := true;\xa" "\x9" "\x9" "while i is not null loop\xa" "\x9" "\x9" ""
"\x9" "t_name := upper (table_name (i));\xa" "\x9" "\x9" "\x9" "open column_"
"cursor for select * from user_tab_columns where table_name = t_name;\xa" ""
"\x9" "\x9" "\x9" "loop\xa" "\x9" "\x9" "\x9" "\x9" "fetch column_cursor "
"into current_row;\xa" "\x9" "\x9" "\x9" "\x9" "exit when column_cursor%notf"
"ound;\xa" "\x9" "\x9" "\x9" "\x9" "if is_first = true then\xa" "\x9" ""
"\x9" "\x9" "\x9" "\x9" "is_first := false;\xa" "\x9" "\x9" "\x9" ""
"\x9" "else\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "res := res || ',';\xa" ""
"\x9" "\x9" "\x9" "\x9" "end if;\xa" "\xa" "\x9" "\x9" "\x9" "\x9" "if "
"current_row.type = 'NUMBER' or current_row.type = 'FLOAT' then\xa" "\x9" ""
"\x9" "\x9" "\x9" "\x9" "agg_func := 'shield_arb_agg_num';\xa" "\x9" ""
"\x9" "\x9" "\x9" "elsif current_row.type = 'CLOB' then\xa" "\x9" "\x9" ""
"\x9" "\x9" "\x9" "agg_func := 'arb_agg_func_clob';\xa" "\x9" "\x9" ""
"\x9" "\x9" "else\xa" "\x9" "\x9" "\x9" "\x9" "\x9" "agg_func := 'arb_agg"
"_func_char';\xa" "\x9" "\x9" "\x9" "\x9" "end if;\xa" "\xa" "\x9" ""
"\x9" "\x9" "\x9" "res := res || agg_func || ' (' || lower (t_name) || '.' || "
"lower (current_row.column_name) || ')';\xa" "\x9" "\x9" "\x9" "end loop;"
"\xa" "\xa" "\x9" "\x9" "\x9" "i := table_name.next (i);\xa" "\x9" ""
"\x9" "end loop;\xa" "\xa" "\xa" "\x9" "\x9" "res := res || ' ' || post;"
"\x9" "\xa" "\x9" "\x9" "dbms_output.put_line( res);\xa" "\x9" "\x9" "retu"
"rn 0;\xa" "\x9" "end;\xa" "\xa" "end shield;\xa" "/\xa" "\xa" "\xa" "cre"
"ate or replace trigger after_logon\xa" "\x9" "after logon \xa" "\x9" "on dat"
"abase\xa" "begin\xa" "\x9" "execute immediate 'alter session set nls_date_for"
"mat=''yyyymmddhh24miss''';\xa" "end;\xa" "/\xa" "\xa" "alter session set nls"
"_date_format='yyyymmddhh24miss';\xa" "\xa" "declare\xa" "\x9" "res number;"
"\xa" "begin\xa" "\x9" "res := shield.make_select_query ('select', 'from test2"
" group by test2.id;', shield_list ('test2'));\xa" "end;\xa" "/\xa" "";
}
